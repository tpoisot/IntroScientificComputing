<!doctype html><html><head><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.6.1/css/all.css integrity=sha384-gfdkjb5BdAXd+lj+gudLWI+BXq4IuLW5IT+brZEZsLFm++aCMlF1V92rMkPaX4PP crossorigin=anonymous><link rel=stylesheet href=//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css><script src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.js></script><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=https://sciencecomputing.io/configuration.c8305aa9a0d8525773466c556a1099c45a385db117ff69fbb4e0f9b71270247d.css><link rel=stylesheet href=https://sciencecomputing.io/index.b194f092783c448e1a2fb1f1f187e85f0542bd11d9b39e67d18bd71432c92e3f.css><meta charset=utf-8><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css integrity=sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js integrity=sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js integrity=sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"$",right:"$",display:false}]});});</script><title>Booleans and conditionals Â· Scientific computing</title></head><body><nav id=main class=sidebar><img src=/logo.png alt style=position:absolute;left:50%;width:56px;margin-left:-28px;margin-top:5px><div class=header><h1><a href=/>Scientific computing</a></h1><h2>(for the rest of us)</h2></div><ul class=nav><li class=lessons><i class="fas fa-fw fa-book-open"></i><a class="sidebar-nav-item active" href=/lessons/>Lessons</a></li><li class=primers><i class="fas fa-fw fa-bolt"></i><a class=sidebar-nav-item href=/primers/>Primers</a></li><li class=capstones><i class="fas fa-fw fa-star"></i><a class=sidebar-nav-item href=/capstones/>Capstones</a></li></ul></nav><section id=content><section class=introduction><h2 id=programming-really-is-a-language>Programming really <em>is</em> a language</h2><p>But if you understand three words, you will be able to hold a good conversation
with your computer! These three words are <em>if</em>, <em>for</em>, and <em>while</em>. If you have
some previous experience with writing code, you can skim through this lesson and
the next.</p><p>One great way to make your code robust is to keep it very simple, and one great
way to keep your code very simple is to recognize that often, we want to do one
of three things: do one thing if something happens (<code>if</code>), do one thing to a
series of things (<code>for</code>), or do one thing until something happens (<code>while</code>).
These three possibilities define what we call the <em>control flow</em>, or the <em>flow
of execution</em>. In the current lesson, we will focus on understanding the <code>if</code>
statement.</p><h2 id=after-this-lesson-you-will-be-able-to->After this lesson, you will be able to &mldr;</h2><ul><li>&mldr; express your problems in Boolean terms (true/false)</li><li>&mldr; understand the different Boolean operators</li><li>&mldr; create conditionals</li></ul><h2 id=tossing-coins-and-planning-trips>Tossing coins and planning trips</h2><p>Let&rsquo;s imagine a situation where we have a coin, and we can toss this coin. One
output of this observation is whether the coin landed on its head, or on its
tail. We can express the outcome of coin toss as a <em>statement</em>: &ldquo;it is true that
the coin landed on its head&rdquo;, or &ldquo;it is not true that the coin landed on its
head&rdquo;.</p><p>This is not how we would think about the outcome as humans. It would be more
natural to say &ldquo;head&rdquo; or &ldquo;tail&rdquo;. But expressing things as <em>true</em> or not true
(which we call <em>false</em>) is much more easier for computers to understand. A great
deal of programming is finding out ways to reduce the outcomes to <em>true</em>/<em>false</em>
statements.</p><p>In fact, there is a name for this type of data: Boolean. In the Boolean world,
things are either <em>true</em>, or <em>false</em>, and we decide accordingly. Very often, we
think in Boolean terms without noticing it! For example, when wondering if it is
faster to go to work by bus, or by bike, we are expressing in our own way the
question of &ldquo;going to work by bus is faster than by bike, true or false?&rdquo;.</p><p>And then, we will of course take a decision based on the outcome of this
question. &ldquo;If it is faster to go by bike, then I will go by bike&rdquo;.</p><p>Have you noticed that the word <em>if</em> appeared a lot in the past few sentences? It
is because <code>if</code> is the first way to control the flow of execution. It is one of
the words that many programming languages already know (we call these
<em>keywords</em>), and it lets us decide what to do when confronted with alternative
choices.</p><p>Let&rsquo;s say I am sitting in my office, and I need to attend a meeting on the other
side of campus. After looking at the itinerary, I can either bike (4 minutes) or
walk (13 minutes). To decide what to do, I can ask the following question to my
computer:</p><pre><code>walking takes 13 minutes
biking takes 4 minutes
if (walking is faster than biking)
    tell me to walk
</code></pre><p>This block above is called <em>pseudocode</em>. It is a way to start expressing our
ideas in a language we can understand, but that resembles what the computer
speaks. We will write quite a lot of it.</p><p>Now, let&rsquo;s give this a try - before you do, what do you think will happen?</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>time_by_foot</span> <span class=o>=</span> <span class=mi>13</span>
<span class=n>time_by_bike</span> <span class=o>=</span> <span class=mi>4</span>
<span class=k>if</span> <span class=n>time_by_foot</span> <span class=o>&lt;</span> <span class=n>time_by_bike</span>
    <span class=n>println</span><span class=p>(</span><span class=s>&#34;You should walk&#34;</span><span class=p>)</span>
<span class=k>end</span>
</code></pre></div><p>Uh, weird! Nothing happened.</p><p>Let&rsquo;s think about why. We asked the computer to compare the time by foot and the
time by bike; if the time by foot is shorter, then we print a line (<code>println</code>)
telling us to walk. But we know that the time by foot is <em>not</em> shorter, and so
does the computer. And for this reason, whatever is between <code>if</code> and <code>end</code> is
<em>not</em> executed. Testing that conditions are met are one way to save time &ndash; we
do not want to run operations that are not useful.</p><p>In the above example, we gave no alternative to the computer. To decide between
two (or more) things to do, we need to use <code>if</code>'s frequent partner: <code>else</code>.
Let&rsquo;s try again:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>time_by_foot</span> <span class=o>=</span> <span class=mi>13</span>
<span class=n>time_by_bike</span> <span class=o>=</span> <span class=mi>4</span>
<span class=k>if</span> <span class=n>time_by_foot</span> <span class=o>&lt;</span> <span class=n>time_by_bike</span>
    <span class=n>println</span><span class=p>(</span><span class=s>&#34;You should walk&#34;</span><span class=p>)</span>
<span class=k>else</span>
    <span class=n>println</span><span class=p>(</span><span class=s>&#34;You should bike&#34;</span><span class=p>)</span>
<span class=k>end</span>
</code></pre></div><pre><code>You should bike
</code></pre><p>This time, we get the right output: <code>You should bike</code>. This brings a very
important point: we need to be <em>explicit</em>; when talking with humans, we can
understand (or guess) what the alternative choice is. Computers have no such
abilities: everything that happens is the outcome of things we (or others) have
written in the code.</p><p>In practice, we will want to make decisions based on several factors. This is a
thing at which Boolean values excel: we can perform <em>operations</em> on them. The
most common ones are <em>not</em>, <em>or</em>, and <em>and</em>.</p><p>The <em>not</em> operation is, quite literaly, the opposite of a statement. For
example, if we state &ldquo;it is true that the coin landed on its head&rdquo;, then <em>not</em>
this statement is &ldquo;it is <em>not</em> true that the coin landed on its head&rdquo;, which is
the same thing as &ldquo;it is false than the coin landed on its head&rdquo;.</p><p>Most programming languages use <code>!x</code> to mean <em>not x</em>. If we run the code below,
what you do think will happen?</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>println</span><span class=p>(</span><span class=o>!</span><span class=kc>true</span><span class=p>)</span>
<span class=n>println</span><span class=p>(</span><span class=o>!</span><span class=kc>false</span><span class=p>)</span>
</code></pre></div><pre><code>false
true
</code></pre><p>Adding <code>!</code> in front of a statement will return the <em>other</em> Boolean value.</p><p>Boolean values can also be <em>combined</em>. Coming back to deciding on a mode of
transportation: the same trip by subway would take 8 minutes. Biking is still
faster, but what if it is raining? We can add a rule, to say:</p><pre><code>if it rains
    take the subway
else
    if the subway is faster than biking
        take the subway
    else
        take the bike
</code></pre><p>This block above is called a <em>nested</em> statement. We start with an <code>if</code>, and then
<em>within it</em>, have another <code>if</code>. This is not <em>too</em> bad, but increasing the
nestedness of statements is a very effective way of having too much complexity!
And too much complexity is, in turn, a great way to introduce mistakes that are
hard to understand. This is, generally, the opposite of what we want to do.</p><p>So we can re-word this expression slightly:</p><pre><code>if (the subway is faster than the bike) or (it rains)
    take the subway
else
    take the bike
</code></pre><p>There is a new word here: <em>or</em>. The <em>or</em> operator will look at both statements
(Is the subway faster? Is it raining?), and return <code>true</code> if <em>either</em> of them is
true. Let&rsquo;s have a look:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>println</span><span class=p>(</span><span class=s>&#34;true or false:</span><span class=se>\t</span><span class=s>&#34;</span><span class=p>,</span> <span class=kc>true</span> <span class=o>||</span> <span class=kc>false</span><span class=p>)</span>
<span class=n>println</span><span class=p>(</span><span class=s>&#34;false or false:</span><span class=se>\t</span><span class=s>&#34;</span><span class=p>,</span> <span class=kc>false</span> <span class=o>||</span> <span class=kc>false</span><span class=p>)</span>
<span class=n>println</span><span class=p>(</span><span class=s>&#34;false or true:</span><span class=se>\t</span><span class=s>&#34;</span><span class=p>,</span> <span class=kc>false</span> <span class=o>||</span> <span class=kc>true</span><span class=p>)</span>
<span class=n>println</span><span class=p>(</span><span class=s>&#34;true or true:</span><span class=se>\t</span><span class=s>&#34;</span><span class=p>,</span> <span class=kc>true</span> <span class=o>||</span> <span class=kc>true</span><span class=p>)</span>
</code></pre></div><pre><code>true or false:	true
false or false:	false
false or true:	true
true or true:	true
</code></pre><p>Most programming languages will use <code>||</code> or <code>or</code> or <code>|</code> to write the <em>or</em>
operation. We can now fine tune our code, to decide between the subway and the
bike, as a function of the weather. Run the cell below: what do you expect?</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>time_by_subway</span> <span class=o>=</span> <span class=mi>8</span>
<span class=n>time_by_bike</span> <span class=o>=</span> <span class=mi>4</span>
<span class=n>rain</span> <span class=o>=</span> <span class=kc>true</span>

<span class=k>if</span> <span class=p>(</span><span class=n>time_by_subway</span> <span class=o>&lt;</span> <span class=n>time_by_bike</span><span class=p>)</span> <span class=o>|</span> <span class=n>rain</span>
    <span class=n>println</span><span class=p>(</span><span class=s>&#34;You should take the subway&#34;</span><span class=p>)</span>
<span class=k>else</span>
    <span class=n>println</span><span class=p>(</span><span class=s>&#34;You should bike&#34;</span><span class=p>)</span>
<span class=k>end</span>
</code></pre></div><pre><code>You should take the subway
</code></pre><p>Because it rains (<code>rain = true</code>), our code is correctly telling us to take the
subway.</p><div class=question id=stopraining><h1><i class="fa fa-question-circle" aria-hidden=true></i>Who'll stop the rain?</h1><div class=text>Now, what would you change to make it stop raining? And what do you expect to
see as an output?
<button type=button onclick="document.getElementById('answer-stopraining').classList.toggle('hidden');">See the answer</button></div><div class="answer hidden" id=answer-stopraining>Correct! If you change the <code>rain = true</code> to <code>rain = false</code>, and re-run this
example, the code will tell us to bike, because it is faster.</div></div><p>At this point, it is important to note that there are many, many ways to write
the same code. Maybe you would like to ask the question &ldquo;Is it <em>not</em> raining?&rdquo;
instead, or decide which mode of transporation takes the longest time. As long
as they give the correct answer, all of these formulations are valid. The
important thing is that they let you write code that is easy to read, and easy
to understand.</p><p>What if nested statements are easier to understand for you? Well, this is fine.
The most important thing is to write code that prevents you from making
mistakes. If you are more confident in your nested statements, then use them!</p><p>Before we move on, there is a final operation on Booleans we need to discuss:
<em>and</em>. Most programming languages will use <code>&</code> or <code>&&</code> or <code>and</code> to describe it.
The <em>and</em> operation will look at both statements, and return <em>true</em> only if both
are <em>true</em>:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>println</span><span class=p>(</span><span class=s>&#34;true and false:</span><span class=se>\t</span><span class=s>&#34;</span><span class=p>,</span> <span class=kc>true</span> <span class=o>&amp;&amp;</span> <span class=kc>false</span><span class=p>)</span>
<span class=n>println</span><span class=p>(</span><span class=s>&#34;false and false:</span><span class=se>\t</span><span class=s>&#34;</span><span class=p>,</span> <span class=kc>false</span> <span class=o>&amp;&amp;</span> <span class=kc>false</span><span class=p>)</span>
<span class=n>println</span><span class=p>(</span><span class=s>&#34;false and true:</span><span class=se>\t</span><span class=s>&#34;</span><span class=p>,</span> <span class=kc>false</span> <span class=o>&amp;&amp;</span> <span class=kc>true</span><span class=p>)</span>
<span class=n>println</span><span class=p>(</span><span class=s>&#34;true and true:</span><span class=se>\t</span><span class=s>&#34;</span><span class=p>,</span> <span class=kc>true</span> <span class=o>&amp;&amp;</span> <span class=kc>true</span><span class=p>)</span>
</code></pre></div><pre><code>true and false:	false
false and false:	false
false and true:	false
true and true:	true
</code></pre><p><strong>So far</strong>, we have learned about Boolean values, and the <em>if</em> operation. Using
<em>if</em> is a way to look at a statement, and do different things when it is true or
false. In a lot of cases, we want to also perform operations on a large number
of elements. To do so, we will use the second word: <em>for</em>. But because it is a
confusing one, we will do so in the <a href=https://sciencecomputing.io/lessons/iteration/>next lesson</a>.</p></section></section><script>mermaid.initialize({startOnLoad:true,theme:"neutral",curve:"basis"});</script></body></html>