<!doctype html><html><head><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.6.1/css/all.css integrity=sha384-gfdkjb5BdAXd+lj+gudLWI+BXq4IuLW5IT+brZEZsLFm++aCMlF1V92rMkPaX4PP crossorigin=anonymous><link rel=stylesheet href=//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css><script src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.js></script><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=https://sciencecomputing.io/configuration.c8305aa9a0d8525773466c556a1099c45a385db117ff69fbb4e0f9b71270247d.css><link rel=stylesheet href=https://sciencecomputing.io/index.b194f092783c448e1a2fb1f1f187e85f0542bd11d9b39e67d18bd71432c92e3f.css><meta charset=utf-8><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css integrity=sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js integrity=sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js integrity=sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"$",right:"$",display:false}]});});</script><title>Before we start... · Scientific computing</title></head><body><nav id=main class=sidebar><img src=/logo.png alt style=position:absolute;left:50%;width:56px;margin-left:-28px;margin-top:5px><div class=header><h1><a href=/>Scientific computing</a></h1><h2>(for the rest of us)</h2></div><ul class=nav><li class=lessons><i class="fas fa-fw fa-book-open"></i><a class="sidebar-nav-item active" href=/lessons/>Lessons</a></li><li class=primers><i class="fas fa-fw fa-bolt"></i><a class=sidebar-nav-item href=/primers/>Primers</a></li><li class=capstones><i class="fas fa-fw fa-star"></i><a class=sidebar-nav-item href=/capstones/>Capstones</a></li></ul></nav><section id=content><section class=introduction><h2 id=programming-is-intimidating>Programming is intimidating</h2><p>If your working environment looks anything like mine, the first thing you may
see on a new project will look like this:</p><pre><code>tpoisot@x1:~$ julia
               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type &quot;?&quot; for help, &quot;]?&quot; for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.5.3 (2020-11-09)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |

julia&gt; 
</code></pre><p>This is highly intimidating.</p><p>Facing an empty text editor or a blinking REPL (it stands for Read/Execute/Print
Loop, and this the place where you type things) prompt at the beginning of a
programming task is like facing an empty page at the beginning of a writing
project. To make it easier to work through, one really good (but also really
uncommon) approach is to walk away from the computer. Instead of trying to write
code, we will first try to articulate the structure of our project - and not
jumping to our keyboard works really well for this.</p><p>In this lesson, we will see how we can optimize our preparation for any project,
by having good project organization, thinking about the flowchart of our
program, and writing pseudo-code as needed.</p><h2 id=after-this-lesson-you-will-be-able-to->After this lesson, you will be able to &mldr;</h2><ul><li>&mldr; organize a project</li><li>&mldr; write the flowchart of your program</li><li>&mldr; work out some of the most complex pieces using pseudo-code</li></ul><h2 id=project-management>Project management</h2><p>Here is a productivity tip: work in such a way that you do not need to think
about the non-important parts of your project. For us, this means having a
standard layout for any project, and using it consistently. We will suggest one
such layout below, but this is not the only one. There are an infinity of them,
and the one that <em>works</em> is the one that works <em>for you</em>.</p><p>Still, there are some good guidelines to follow.</p><p>First, a project is a folder, everything in the project belongs to the folder,
and everything outside the folder cannot belong to the project. This is
important because it maximizes the chances that you can copy your project to
another computer, and have it &ldquo;just work&rdquo;. Of course in real life, things seldom
&ldquo;just work&rdquo;, and this is why we should pay extra care to the practices that
maximise the chances of it being the case.</p><div class="callout information">This is not necessarily true if your project involves remote computing - or very
large amounts of data. But then again, if you work in such a way, we expect that
you will have read the documentation, and sought proper training.</div><p>Second, file paths are not your friends. By far the biggest obstacle to
reproducibility is the difference in ways to tell the computer <em>where files
are</em>. We encourage to use <em>relative paths</em>, relative specifically to the folder
in which your project lives. So, for example,</p><pre><code class=language-raw data-lang=raw>/home/tim/ohno/my/computer/is_a_mess/MyCoolProject/data/file.txt
</code></pre><p>is an <em>absolute</em> file path, from the very root of where files live. But I am
only working on <code>MyCoolProject</code> at the moment, so the <em>relative</em> path of this
file is</p><pre><code class=language-raw data-lang=raw>data/file.txt
</code></pre><p>Or is it? On my machine running Linux, sure. But on a Windows machine I would
use in a computer lab? The file would be at</p><pre><code class=language-raw data-lang=raw>data\file.txt
</code></pre><p>This difference between <code>/</code> and <code>\</code> is trivial to us, but <em>not</em> to the computer
(they are, actually, trivial to <em>Julia</em> which tends to parse paths well all the
time). So to avoid these issues, it is better to let your programming language
construct the path correclty. <em>Julia</em> has the <code>joinpath</code> function, and so we
would refer to this file as:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>joinpath</span><span class=p>(</span><span class=s>&#34;data&#34;</span><span class=p>,</span> <span class=s>&#34;file.txt&#34;</span><span class=p>)</span>
</code></pre></div><pre><code>&quot;data/file.txt&quot;
</code></pre><p>Third, and final principle, similar things should be grouped together. In other
words, it will be easier to navigate our project if there is a folder called
<code>data</code> and it contains data, a folder called <code>figures</code> and it contains figures,
and a folder called <code>code</code> which contains code. The name and variety of these
folders is left up to you.</p><p>With this in mind, here is a possible template for a project.</p><pre><code class=language-raw data-lang=raw>.
├── .git                    # We use version control, always!
│   └── ...
├── artifacts               # Outputs that are not figures go here
│   └── summary.csv
├── code                    # Code that creates something goes here
│   ├── figure01.jl
│   └── simulations.jl
├── data                    # Raw data goes here
│   └── BCI.data
├── lib                     # Useful functions go here
│   ├── environmentaldata.jl
│   └── model.jl
├── LICENSE                 # We use a license, always!
├── README.md               # Also mandatory: a README
├── Project.toml
├── Manifest.toml
└── text                    # This folder can store notes and documents
    └── notes.md
</code></pre><p>There are a few files here on which it is worth spending a little more time.
Their names are presented below as links, to the resource that we think is the
most informative. It is, indeed, a very good idea to read the content of these
links as well.</p><p>The <a href=readme>README</a> is a standard file for all projects, which gives
information about the project, how to run it, the dependencies, who is in
charge, <em>etc</em>. Writing a good README is a difficult task, but this is going to
be the point of entry in your project. Show it some love.</p><p><a href=license>LICENSE</a> is the text of a license, which gives information about
intellectual property and your own liability regarding the use of your project.
Picking FOSS (Free and Open Source Software) licenses is recommended, and there
are a lot of the to accomodate different use cases.</p><p>Finally, and these are language-specific, the <a href=pkg><em>Julia</em> package manager</a>
will create files to track the dependencies of your project. Check out the
documentation.</p><h2 id=flowcharts>Flowcharts</h2><p>One of the most powerful tool to plan a programming task is to draw a flochart.
In simple terms, a flowchart will let you map the different steps that the
program will have to follow, and see what is required for each of them. To
illustrate, we will use a flowchart not of a program, but of a pancake recipe.</p><p>At the beginning, it can be useful to break the task down into coarse steps:</p><div class=mermaid align=center>graph LR
prepare --> cook
cook --> eat</div><p>This is not much to look at, but this is a very high-level view of what we want
to achieve. It is also easy to zoom in on every task, and try to further break
it down into smaller tasks. Let&rsquo;s do this for the task at left: <em>prepare</em>.</p><div class=mermaid align=center>graph LR
liquid[liquid ingredients] --> batter
solid[solid ingredients] --> batter
batter --> cook
cook --> eat</div><p>&ldquo;All&rdquo; we have done so far is to split the <em>prepare</em> step into the preparation of
solid and liquid ingredients. To come up with a full flowchart, we need to
repeat this process until we are satisfied by the completeness of it:</p><div class=mermaid align=center>graph LR
liquid[liquid ingredients] --> mix{mix}
solid[solid ingredients] --> mix
mix --> batter
batter --> cook{cook}
cook --> eat{eat}</div><p>Notice that we have introduced a new shape: the rotated square will be used to
note <em>actions</em>, and anything else will be either an output or an input of these
actions.</p><div class="callout opinion">We like the idea of using different shapes to indicate different steps: what
goes in, what is the action, are there any artifacts produced or side-effects?
This being said, even a very coarse flowchart can help you.</div><p>If we repeat the exercise for most of the boxes, we may end up with a flowchart
like this. It might seem a little overwhelming at first, but this is a helpful
document. It maps out the precise steps and processes in your project, and can
help you both to <em>plan</em> what to write, but also to <em>understand</em> what you have
written previously.</p><div class=mermaid align=center>graph TD
flour --> sift{sift}
sugar --> mix1{mix}
bak[baking powder] --> mix1
salt --> mix1
sift --> mix1
milk --> mix2{mix}
eggs --> whisk1{whisk}
whisk1 --> mix2
butter --> melt{melt}
melt --> mix2
mix1 --> combine{combine}
mix2 --> combine
combine --> batter
griddle[flat griddle] --> heat{heat}
batter --> cook{cook}
heat --> cook
cook --> flip{flip}
flip --> cook2{cook}
cook2 --> pancake
pancake --> eat{eat}</div><p>See how a simple task (&ldquo;make crepes!") can be broken down into dozens of litle
steps, each representing a single well-defined action? Programming is,
essentially, that. We are going to need to specificy things as unambiguously as
possible, and breaking the big tasks down is going to be immensely helpful.</p><h2 id=pseudo-code>Pseudo-code</h2><p>To facilitate the transition between diagram and code, one important step is to
write <em>pseudo-code</em>, <em>i.e.</em> text that looks reasonably like code, but is not.</p><div class="callout opinion">Pseudo-code is mostly useful when it comes to working on a single function. The
overall structure of the project can be done as a flowchart, and then each
function can be written as pseudo-code. This is, in fact, a really good exercise
to try with your own projects.</div><p>Let us try with an example - we want to sort numbers. We will write pseudo-code
for a very, <em>veru</em> inefficient algorithm:</p><pre><code>take a list of numbers X
create an empty list Y

as long as X still has elements in it
    find the minimum of X
    add it to Y
    remove it from X

return Y
</code></pre><p>This is, essentially, what <em>pseudo-code</em> is: a way to explain in your own words
what the function should do. This can be translated line-by-line into code:</p><table><thead><tr><th>Pseudo-code</th><th>Code</th></tr></thead><tbody><tr><td><code>take a list of numbers X</code></td><td><code>function badsort(X::Vector{T}) where {T &lt;: Number}</code></td></tr><tr><td><code>create an empty list Y</code></td><td><code>Y = eltype(X)[]</code></td></tr><tr><td><code>as long as X still has elements in it</code></td><td><code>while length(X) > 0</code></td></tr><tr><td><code>find the minimum of X</code></td><td><code>m, i = findmin(X)</code></td></tr><tr><td><code>add it to Y</code></td><td><code>push!(Y, m)</code></td></tr><tr><td><code>remove it from X</code></td><td><code>deleteat!(X, i)</code></td></tr><tr><td></td><td><code>end</code></td></tr><tr><td><code>return Y</code></td><td><code>return Y</code></td></tr><tr><td></td><td><code>end</code></td></tr></tbody></table><p>The right column is <em>actual</em> code! In practice, we rarely (never!) convert
pseudo-code to code literally. But when you are writing your first functions, it
may be a good idea.</p></section></section><script>mermaid.initialize({startOnLoad:true,theme:"neutral",curve:"basis"});</script></body></html>