<!doctype html><html><head><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.6.1/css/all.css integrity=sha384-gfdkjb5BdAXd+lj+gudLWI+BXq4IuLW5IT+brZEZsLFm++aCMlF1V92rMkPaX4PP crossorigin=anonymous><link rel=stylesheet href=//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css><script src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.js></script><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/configuration.css><link rel=stylesheet href=/css/index.css><meta charset=utf-8><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css integrity=sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js integrity=sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js integrity=sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"$",right:"$",display:false}]});});</script><title>The flow of execution Â· Scientific computing</title></head><body><nav id=main class=sidebar><div class=toggle><a class=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><line x1="0" y1="20" x2="100" y2="20" /><line x1="0" y1="50" x2="100" y2="50" /><line x1="0" y1="80" x2="100" y2="80" /></svg></a></div><div class=header><h1><a href=/>Scientific computing</a></h1><h2>(for the rest of us)</h2></div><ul class=nav><li class=lessons><i class="fas fa-fw fa-book-open"></i><a class="sidebar-nav-item active" href=/lessons/>Lessons</a></li><li class=primers><i class="fas fa-fw fa-bolt"></i><a class=sidebar-nav-item href=/primers/>Primers</a></li><li class=capstones><i class="fas fa-fw fa-star"></i><a class=sidebar-nav-item href=/capstones/>Capstones</a></li><li class=ml><i class="fas fa-fw fa-brain"></i><a class=sidebar-nav-item href=/machinelearning/>Machine Learning</a></li><li class=main><i class="fas fa-fw fa-pen"></i><a class=sidebar-nav-item href=https://github.com/tpoisot/ScientificComputingForTheRestOfUs>Contribute!</a></li></ul></nav><section id=content><h2 id=programming-really-is-a-language>Programming really <em>is</em> a language</h2><p>But if you understand three words, you will be able to hold a good conversation
with your computer! These three words are <em>if</em>, <em>for</em>, and <em>while</em>. If you have
some previous experience with writing code, you can skim through this lesson.</p><p>One great way to make your code robust is to keep it very simple, and one great
way to keep your code very simple is to recognize that often, we want to do one
of three things: do one thing if something happens (<code>if</code>), do one thing to a
series of things (<code>for</code>), or do one thing until something happens (<code>while</code>).
These three possibilities define what we call the <em>control flow</em>, or the <em>flow
of execution</em>.</p><h2 id=after-this-lesson-you-will-be-able-to->After this lesson, you will be able to &mldr;</h2><ul><li>&mldr; express your problems in Boolean terms (true/false)</li><li>&mldr; create loops and conditionals</li><li>&mldr; navigate in arrays</li><li>&mldr; understand the difference between <code>for</code> and <code>while</code></li></ul><h2 id=tossing-coins-and-planning-trips>Tossing coins and planning trips</h2><p>Let's imagine a situation where we have a coin, and we can toss this coin. One
output of this observation is whether the coin landed on its head, or on its
tail. We can express the outcome of coin toss as a <em>statement</em>: &ldquo;it is true that
the coin landed on its head&rdquo;, or &ldquo;it is not true that the coin landed on its
head&rdquo;.</p><p>This is not how we would think about the outcome as humans. It would be more
natural to say &ldquo;head&rdquo; or &ldquo;tail&rdquo;. But expressing things as <em>true</em> or not true
(which we call <em>false</em>) is much more easier for computers to understand. A great
deal of programming is finding out ways to reduce the outcomes to <em>true</em>/<em>false</em>
statements.</p><p>In fact, there is a name for this type of data: Boolean. In the Boolean world,
things are either <em>true</em>, or <em>false</em>, and we decide accordingly. Very often, we
think in Boolean terms without noticing it! For example, when wondering if it is
faster to go to work by bus, or by bike, we are expressing in our own way the
question of &ldquo;going to work by bus is faster than by bike, true or false?".</p><p>And then, we will of course take a decision based on the outcome of this
question. &ldquo;If it is faster to go by bike, then I will go by bike&rdquo;.</p><p>Have you noticed that the word <em>if</em> appeared a lot in the past few sentences? It
is because <code>if</code> is the first way to control the flow of execution. It is one of
the words that many programming languages already know (we call these
<em>keywords</em>), and it lets us decide what to do when confronted with alternative
choices.</p><p>Let's say I am sitting in my office, and I need to attend a meeting on the other
side of campus. After looking at the itinerary, I can either bike (4 minutes) or
walk (13 minutes). To decide what to do, I can ask the following question to my
computer:</p><pre><code>walking takes 13 minutes
biking takes 4 minutes
if (walking is faster than biking)
    tell me to walk
</code></pre><p>This block above is called <em>pseudocode</em>. It is a way to start expressing our
ideas in a language we can understand, but that resembles what the computer
speaks. We will write quite a lot of it.</p><p>Now, let's give this a try - before you do, what do you think will happen?</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>time_by_foot</span><span class=o></span> <span class=o>=</span> <span class=mi>13</span>
<span class=n>time_by_bike</span><span class=o></span> <span class=o>=</span> <span class=mi>4</span>
<span class=k>if</span> <span class=n>time_by_foot</span><span class=o></span> <span class=o>&lt;</span> <span class=n>time_by_bike</span><span class=o></span>
    <span class=n>println</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>Y</span><span class=s>o</span><span class=s>u</span><span class=s> </span><span class=s>s</span><span class=s>h</span><span class=s>o</span><span class=s>u</span><span class=s>l</span><span class=s>d</span><span class=s> </span><span class=s>w</span><span class=s>a</span><span class=s>l</span><span class=s>k</span><span class=s>&#34;</span><span class=p>)</span>
<span class=k>end</span>
</code></pre></div><p>Uh, weird! Nothing happened.</p><p>Let's think about why. We asked the computer to compare the time by foot and the
time by bike; if the time by foot is shorter, then we print a line (<code>println</code>)
telling us to walk. But we know that the time by foot is <em>not</em> shorter, and so
does the computer. And for this reason, whatever is between <code>if</code> and <code>end</code> is
<em>not</em> executed. Testing that conditions are met are one way to save time &ndash; we
do not want to run operations that are not useful.</p><p>In the above example, we gave no alternative to the computer. To decide between
two (or more) things to do, we need to use <code>if</code>'s frequent partner: <code>else</code>.
Let's try again:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>time_by_foot</span><span class=o></span> <span class=o>=</span> <span class=mi>13</span>
<span class=n>time_by_bike</span><span class=o></span> <span class=o>=</span> <span class=mi>4</span>
<span class=k>if</span> <span class=n>time_by_foot</span><span class=o></span> <span class=o>&lt;</span> <span class=n>time_by_bike</span><span class=o></span>
    <span class=n>println</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>Y</span><span class=s>o</span><span class=s>u</span><span class=s> </span><span class=s>s</span><span class=s>h</span><span class=s>o</span><span class=s>u</span><span class=s>l</span><span class=s>d</span><span class=s> </span><span class=s>w</span><span class=s>a</span><span class=s>l</span><span class=s>k</span><span class=s>&#34;</span><span class=p>)</span>
<span class=k>else</span>
    <span class=n>println</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>Y</span><span class=s>o</span><span class=s>u</span><span class=s> </span><span class=s>s</span><span class=s>h</span><span class=s>o</span><span class=s>u</span><span class=s>l</span><span class=s>d</span><span class=s> </span><span class=s>b</span><span class=s>i</span><span class=s>k</span><span class=s>e</span><span class=s>&#34;</span><span class=p>)</span>
<span class=k>end</span>
</code></pre></div><pre><code>You should bike
</code></pre><p>This time, we get the right output: <code>You should bike</code>. This brings a very
important point: we need to be <em>explicit</em>; when talking with humans, we can
understand (or guess) what the alternative choice is. Computers have no such
abilities: everything that happens is the outcome of things we (or others) have
written in the code.</p><p>In practice, we will want to make decisions based on several factors. This is a
thing at which Boolean values excel: we can perform <em>operations</em> on them. The
most common ones are <em>not</em>, <em>or</em>, and <em>and</em>.</p><p>The <em>not</em> operation is, quite literaly, the opposite of a statement. For
example, if we state &ldquo;it is true that the coin landed on its head&rdquo;, then <em>not</em>
this statement is &ldquo;it is <em>not</em> true that the coin landed on its head&rdquo;, which is
the same thing as &ldquo;it is false than the coin landed on its head&rdquo;.</p><p>Most programming languages use <code>!x</code> to mean <em>not x</em>. If we run the code below,
what you do think will happen?</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>println</span><span class=o></span><span class=p>(</span><span class=o>!</span><span class=kc>true</span><span class=p>)</span>
</code></pre></div><pre><code>false
</code></pre><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>println</span><span class=o></span><span class=p>(</span><span class=o>!</span><span class=kc>false</span><span class=p>)</span>
</code></pre></div><pre><code>true
</code></pre><p>Adding <code>!</code> in front of a statement will return the <em>other</em> Boolean value.</p><p>Boolean values can also be <em>combined</em>. Coming back to deciding on a mode of
transportation: the same trip by subway would take 8 minutes. Biking is still
faster, but what if it is raining? We can add a rule, to say:</p><pre><code>if it rains
    take the subway
else
    if the subway is faster than biking
        take the subway
    else
        take the bike
</code></pre><p>This block above is called a <em>nested</em> statement. We start with an <code>if</code>, and then
<em>within it</em>, have another <code>if</code>. This is not <em>too</em> bad, but increasing the
nestedness of statements is a very effective way of having too much complexity!
And too much complexity is, in turn, a great way to introduce mistakes that are
hard to understand. This is, generally, the opposite of what we want to do.</p><p>So we can re-word this expression slightly:</p><pre><code>if (the subway is faster than the bike) or (it rains)
    take the subway
else
    take the bike
</code></pre><p>There is a new word here: <em>or</em>. The <em>or</em> operator will look at both statements
(Is the subway faster? Is it raining?), and return <code>true</code> if <em>either</em> of them is
true. Let's have a look:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>println</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>t</span><span class=s>r</span><span class=s>u</span><span class=s>e</span><span class=s> </span><span class=s>o</span><span class=s>r</span><span class=s> </span><span class=s>f</span><span class=s>a</span><span class=s>l</span><span class=s>s</span><span class=s>e</span><span class=s>:</span><span class=se>\t</span><span class=s>&#34;</span><span class=p>,</span> <span class=kc>true</span> <span class=o>||</span> <span class=kc>false</span><span class=p>)</span>
</code></pre></div><pre><code>true or false:	true
</code></pre><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>println</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>f</span><span class=s>a</span><span class=s>l</span><span class=s>s</span><span class=s>e</span><span class=s> </span><span class=s>o</span><span class=s>r</span><span class=s> </span><span class=s>f</span><span class=s>a</span><span class=s>l</span><span class=s>s</span><span class=s>e</span><span class=s>:</span><span class=se>\t</span><span class=s>&#34;</span><span class=p>,</span> <span class=kc>false</span> <span class=o>||</span> <span class=kc>false</span><span class=p>)</span>
</code></pre></div><pre><code>false or false:	false
</code></pre><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>println</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>f</span><span class=s>a</span><span class=s>l</span><span class=s>s</span><span class=s>e</span><span class=s> </span><span class=s>o</span><span class=s>r</span><span class=s> </span><span class=s>t</span><span class=s>r</span><span class=s>u</span><span class=s>e</span><span class=s>:</span><span class=se>\t</span><span class=s>&#34;</span><span class=p>,</span> <span class=kc>false</span> <span class=o>||</span> <span class=kc>true</span><span class=p>)</span>
</code></pre></div><pre><code>false or true:	true
</code></pre><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>println</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>t</span><span class=s>r</span><span class=s>u</span><span class=s>e</span><span class=s> </span><span class=s>o</span><span class=s>r</span><span class=s> </span><span class=s>t</span><span class=s>r</span><span class=s>u</span><span class=s>e</span><span class=s>:</span><span class=se>\t</span><span class=s>&#34;</span><span class=p>,</span> <span class=kc>true</span> <span class=o>||</span> <span class=kc>true</span><span class=p>)</span>
</code></pre></div><pre><code>true or true:	true
</code></pre><p>Most programming languages will use <code>||</code> or <code>or</code> or <code>|</code> to write the <em>or</em>
operation. We can now fine tune our code, to decide between the subway and the
bike, as a function of the weather. Run the cell below: what do you expect?</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>time_by_subway</span><span class=o></span> <span class=o>=</span> <span class=mi>8</span>
<span class=n>time_by_bike</span><span class=o></span> <span class=o>=</span> <span class=mi>4</span>
<span class=n>rain</span><span class=o></span> <span class=o>=</span> <span class=kc>true</span>

<span class=k>if</span> <span class=p>(</span><span class=n>time_by_subway</span><span class=o></span> <span class=o>&lt;</span> <span class=n>time_by_bike</span><span class=o></span><span class=p>)</span> <span class=o>|</span> <span class=n>rain</span><span class=o></span>
    <span class=n>println</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>Y</span><span class=s>o</span><span class=s>u</span><span class=s> </span><span class=s>s</span><span class=s>h</span><span class=s>o</span><span class=s>u</span><span class=s>l</span><span class=s>d</span><span class=s> </span><span class=s>t</span><span class=s>a</span><span class=s>k</span><span class=s>e</span><span class=s> </span><span class=s>t</span><span class=s>h</span><span class=s>e</span><span class=s> </span><span class=s>s</span><span class=s>u</span><span class=s>b</span><span class=s>w</span><span class=s>a</span><span class=s>y</span><span class=s>&#34;</span><span class=p>)</span>
<span class=k>else</span>
    <span class=n>println</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>Y</span><span class=s>o</span><span class=s>u</span><span class=s> </span><span class=s>s</span><span class=s>h</span><span class=s>o</span><span class=s>u</span><span class=s>l</span><span class=s>d</span><span class=s> </span><span class=s>b</span><span class=s>i</span><span class=s>k</span><span class=s>e</span><span class=s>&#34;</span><span class=p>)</span>
<span class=k>end</span>
</code></pre></div><pre><code>You should take the subway
</code></pre><p>Because it rains (<code>rain = true</code>), our code is correctly telling us to take the
subway.</p><p>Now, what would you change to make it stop raining? And what do you expect to
see as an output?
{: .question}</p><p>Correct! If you change the <code>rain = true</code> to <code>rain = false</code>, and re-run this
example, the code will tell us to bike, because it is faster.
{: .answer}</p><p>At this point, it is important to note that there are many, many ways to write
the same code. Maybe you would like to ask the question &ldquo;Is it <em>not</em> raining?&rdquo;
instead, or decide which mode of transporation takes the longest time. As long
as they give the correct answer, all of these formulations are valid. The
important thing is that they let you write code that is easy to read, and easy
to understand.</p><p>What if nested statements are easier to understand for you? Well, this is fine.
The most important thing is to write code that prevents you from making
mistakes. If you are more confident in your nested statements, then use them!</p><p>Before we move on, there is a final operation on Booleans we need to discuss:
<em>and</em>. Most programming languages will use <code>&</code> or <code>&&</code> or <code>and</code> to describe it.
The <em>and</em> operation will look at both statements, and return <em>true</em> only if both
are <em>true</em>:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>println</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>t</span><span class=s>r</span><span class=s>u</span><span class=s>e</span><span class=s> </span><span class=s>a</span><span class=s>n</span><span class=s>d</span><span class=s> </span><span class=s>f</span><span class=s>a</span><span class=s>l</span><span class=s>s</span><span class=s>e</span><span class=s>:</span><span class=se>\t</span><span class=s>&#34;</span><span class=p>,</span> <span class=kc>true</span> <span class=o>&amp;&amp;</span> <span class=kc>false</span><span class=p>)</span>
</code></pre></div><pre><code>true and false:	false
</code></pre><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>println</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>f</span><span class=s>a</span><span class=s>l</span><span class=s>s</span><span class=s>e</span><span class=s> </span><span class=s>a</span><span class=s>n</span><span class=s>d</span><span class=s> </span><span class=s>f</span><span class=s>a</span><span class=s>l</span><span class=s>s</span><span class=s>e</span><span class=s>:</span><span class=se>\t</span><span class=s>&#34;</span><span class=p>,</span> <span class=kc>false</span> <span class=o>&amp;&amp;</span> <span class=kc>false</span><span class=p>)</span>
</code></pre></div><pre><code>false and false:	false
</code></pre><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>println</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>f</span><span class=s>a</span><span class=s>l</span><span class=s>s</span><span class=s>e</span><span class=s> </span><span class=s>a</span><span class=s>n</span><span class=s>d</span><span class=s> </span><span class=s>t</span><span class=s>r</span><span class=s>u</span><span class=s>e</span><span class=s>:</span><span class=se>\t</span><span class=s>&#34;</span><span class=p>,</span> <span class=kc>false</span> <span class=o>&amp;&amp;</span> <span class=kc>true</span><span class=p>)</span>
</code></pre></div><pre><code>false and true:	false
</code></pre><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>println</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>t</span><span class=s>r</span><span class=s>u</span><span class=s>e</span><span class=s> </span><span class=s>a</span><span class=s>n</span><span class=s>d</span><span class=s> </span><span class=s>t</span><span class=s>r</span><span class=s>u</span><span class=s>e</span><span class=s>:</span><span class=se>\t</span><span class=s>&#34;</span><span class=p>,</span> <span class=kc>true</span> <span class=o>&amp;&amp;</span> <span class=kc>true</span><span class=p>)</span>
</code></pre></div><pre><code>true and true:	true
</code></pre><p><strong>So far</strong>, we have learned about Boolean values, and the <em>if</em> operation. Using
<em>if</em> is a way to look at a statement, and do different things when it is true
or false. In a lot of cases, we want to also perform operations on a large
number of elements. To do so, we will use the second word: <em>for</em>.</p><h2 id=introducing-iteration>Introducing iteration</h2><p>The <code>for</code> operation is one of the most common, but also one of the most
confusing, ways to tell a computer what to do. This is because it requires to
understand a lot of concepts at once; we will walk through each of them, get
confused a little bit, then get confused a lot, then get it.</p><p>When talking about <code>for</code>, we usually talk about <em>for loops</em> or <em>iteration</em>. This
is because <code>for</code> lets you express the fact that you will perform an operation on
a (finite) set of elements. Let's start with a perfectly boring yet somewhat
instructive example. We can draw five random numbers between 0 and 1, using</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>rand</span><span class=o></span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</code></pre></div><p>We might want to print <em>smol</em> when a number is lower or equal to 0.5, and
<em>chonky</em> in the rest of the situations. In a lot of programming examples, you
will see <em>foo</em> and <em>bar</em>. Why on Earth would we need to print <em>foo</em> and <em>bar</em>?
These are nonsense words used as placeholders by programmers. Of course, what
with us being all fancy, the term you should use instead of nonsense is
&ldquo;metasyntactic variables&rdquo;. But polysyllabic nonsense is nonsense still, and so
we will use the far more dignified <em>smol</em> and <em>chonky</em>:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>random_numbers</span><span class=o></span> <span class=o>=</span> <span class=n>rand</span><span class=o></span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>

<span class=k>for</span> <span class=n>random_number</span><span class=o></span> <span class=kp>in</span> <span class=n>random_numbers</span><span class=o></span>
  <span class=k>if</span> <span class=n>random_number</span><span class=o></span> <span class=o>â¤</span> <span class=mf>0.5</span>
    <span class=n>println</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>s</span><span class=s>m</span><span class=s>o</span><span class=s>l</span><span class=s>&#34;</span><span class=p>)</span>
  <span class=k>else</span>
    <span class=n>println</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>c</span><span class=s>h</span><span class=s>o</span><span class=s>n</span><span class=s>k</span><span class=s>y</span><span class=s>&#34;</span><span class=p>)</span>
  <span class=k>end</span>
<span class=k>end</span>
</code></pre></div><pre><code>smol
smol
chonky
smol
chonky
</code></pre><p>There is quite a lot happening here, so we will go line by line.</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>random_numbers</span><span class=o></span> <span class=o>=</span> <span class=n>rand</span><span class=o></span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</code></pre></div><p>First, we generate 5 random numbers, and put them in a variable called
<code>random_numbers</code>. It is always a good idea to give very explicit names to
variables. To begin with, most code editors will be very good at autocompletion:
type a few letters, then hit the <em>Tab</em> key, and you will see the possible
values.</p><p>Giving plural names to things that have multiple elements is also useful: it
helps to have code that reads like plain english. By contrast, variables whose
name is singular have a single value in them.</p><p>Now we can start the loop itself:</p><pre><code class=language-raw data-lang=raw>for random_number in random_numbers
    # Content of the loop
end
</code></pre><p>This line gives a simple instruction to your computer. Actually, no. It gives a
bunch of complex instructions to your computer, but it is an easy enough
instruction for us to <em>write</em>, and this is all that matters.</p><p>It goes something like this:</p><ol><li>look at what is inside <code>random_numbers</code></li><li>take the first value, and name it <code>random_number</code></li><li>do whatever we tell you to do with this variable until you hit <code>end</code></li><li>move on to the next value of <code>random_numbers</code>, and start again</li><li>when you have exhausted the values in <code>random_numbers</code>, continue to whatever is <em>after</em> the end of the loop</li></ol><p>The <em>for</em> loop is one of the most difficult construct to understand, because of
this &ldquo;change the content of the variable&rdquo; trickery. We will have a few more
examples in this lesson.</p><p>The final lines we need to look at are in the <em>inside</em> of the loop &ndash; we call
this inside thing <em>the body</em> for no particular reason.</p><pre><code class=language-raw data-lang=raw>if random_number â¤ 0.5
    println(&quot;smol&quot;)
else
    println(&quot;chonky&quot;)
end
</code></pre><p>These lines should be familiar to you now &ndash; your computer will evaluate the
statement &ldquo;<code>random_number</code> is lower than or equal to 0.5&rdquo;, and depending on the
truthiness of it, will print either <em>foo</em> or <em>bar</em>.</p><h2 id=navigating-arrays>Navigating arrays</h2><p>Before we move on to a more interesting use of iteration, it is worth
understanding what exactly is in the <code>random_numbers</code> object. Let's display it
again:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>random_numbers</span><span class=o></span>
</code></pre></div><pre><code>5-element Array{Float64,1}:
 0.4333472991211067 
 0.29122770230529405
 0.973686908769203  
 0.4676729638865986 
 0.8164495834274983
</code></pre><p>This type of object is an <em>array</em>; it may help to think of an array as a shelf,
in which every compartment can store one thing. You can have shelves with a
single row, a single column, or both rows and columns. In <em>Julia</em>, arrays are by
default columns, and this is important for applications like linear algebra
(they behave as vectors). Arrays have all sorts of properties, the most
important being their <em>length</em>:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>length</span><span class=o></span><span class=p>(</span><span class=n>random_numbers</span><span class=o></span><span class=p>)</span>
</code></pre></div><pre><code>5
</code></pre><p>This tells us that our &ldquo;shelf&rdquo; has five compartments, so we can store five
things in it. We can also ask what its <em>size</em> is:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>size</span><span class=o></span><span class=p>(</span><span class=n>random_numbers</span><span class=o></span><span class=p>)</span>
</code></pre></div><pre><code>(5,)
</code></pre><p>The output is <code>(5,)</code> - this is the computer way of telling us that this array
has 5 positions in its first <em>dimension</em>, and no positions in its second
dimension: this is a column with five rows. We can also access any <em>position</em> we
like; this is akin to asking &ldquo;computer, give me the content of the 1st
compartment&rdquo;:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>random_numbers</span><span class=o></span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</code></pre></div><pre><code>0.4333472991211067
</code></pre><p>Some languages, like <em>Julia</em>, <em>R</em>, and <em>MatLab</em>, start counting from 1, but
<em>python</em> and <em>C</em> start counting from 0. These are conventions that each language
adopted. Everyone thinks the other camp is wrong, and it's one of these
surprisingly bitter (considering how utterly unimportant they are) divides in
the computer science world.</p><p>We can *also ask what the <em>last</em> position contains:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>random_numbers</span><span class=o></span><span class=p>[</span><span class=n>length</span><span class=o></span><span class=p>(</span><span class=n>random_numbers</span><span class=o></span><span class=p>)</span><span class=p>]</span>
</code></pre></div><pre><code>0.8164495834274983
</code></pre><p>The way to read this instruction is as follows: get me the element at position
<code>length(random_numbers)</code>. We know that the length of <code>random_numbers</code> is <code>5</code>, so
this will return the 5th position. <em>Julia</em> has a quite pretty way of getting the
last element of most collections:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>random_numbers</span><span class=o></span><span class=p>[</span><span class=k>end</span><span class=p>]</span>
</code></pre></div><pre><code>0.8164495834274983
</code></pre><p>An extra bit of <a href=https://en.wikipedia.org/wiki/Syntactic_sugar>syntactic sugar</a> in <em>Julia</em> are the two following
functions:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>first</span><span class=o></span><span class=p>(</span><span class=n>random_numbers</span><span class=o></span><span class=p>)</span>
</code></pre></div><pre><code>0.4333472991211067
</code></pre><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>last</span><span class=o></span><span class=p>(</span><span class=n>random_numbers</span><span class=o></span><span class=p>)</span>
</code></pre></div><pre><code>0.8164495834274983
</code></pre><p>Being able to access elements by their position can be very useful. Our
<code>random_numbers</code> array has five elements, and we only want to print the
odd-numbered ones. One way to do this would be to call then individually:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>println</span><span class=o></span><span class=p>(</span><span class=n>random_numbers</span><span class=o></span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=p>)</span>
</code></pre></div><pre><code>0.4333472991211067
</code></pre><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>println</span><span class=o></span><span class=p>(</span><span class=n>random_numbers</span><span class=o></span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=p>)</span>
</code></pre></div><pre><code>0.973686908769203
</code></pre><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>println</span><span class=o></span><span class=p>(</span><span class=n>random_numbers</span><span class=o></span><span class=p>[</span><span class=mi>5</span><span class=p>]</span><span class=p>)</span>
</code></pre></div><pre><code>0.8164495834274983
</code></pre><p>Of course, this is only reasonable if we have a very small number of things to
do. But what if we want to iterate over hundreds, or thousands of values? We
need a more efficient strategy.</p><h2 id=iterating-over-values>Iterating over values</h2><p>We know that a number is even if the statement <code>x % 2 == 0</code>, where <code>%</code> is
integer division. We can also say that a number is even if the remainder of its
integer division by two is <em>not</em> 0: <code>x % 2 != 0</code>.</p><p>Let's go:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=k>for</span> <span class=n>i</span><span class=o></span> <span class=kp>in</span> <span class=mi>1</span><span class=o>:</span><span class=n>length</span><span class=o></span><span class=p>(</span><span class=n>random_numbers</span><span class=o></span><span class=p>)</span> <span class=c># We could also write `in eachindex(random_numbers)`</span>
  <span class=k>if</span> <span class=n>i</span><span class=o></span> <span class=o>%</span> <span class=mi>2</span> <span class=o>!=</span> <span class=mi>0</span>
    <span class=n>println</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>P</span><span class=s>o</span><span class=s>s</span><span class=s>i</span><span class=s>t</span><span class=s>i</span><span class=s>o</span><span class=s>n</span><span class=s> </span><span class=si>$i</span><span class=s>:</span><span class=se>\t</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>random_numbers</span><span class=o></span><span class=p>[</span><span class=n>i</span><span class=o></span><span class=p>]</span><span class=p>)</span>
  <span class=k>end</span>
<span class=k>end</span>
</code></pre></div><pre><code>Position 1:	0.4333472991211067
Position 3:	0.973686908769203
Position 5:	0.8164495834274983
</code></pre><p>We can &ldquo;read&rdquo; this snippet (a <em>snippet</em> is the affectionate name given to a
litle chunk of code; a <em>chunk</em> is a much uglier name for &ldquo;a piece&rdquo;) as</p><pre><code>there is a variable i
it will take every value between 1 and the length of the ranom_numbers array
for every value
look if it is odd
if it is, print the random number at this position
</code></pre><p>All <code>for</code> loops will share this structure:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=k>for</span> <span class=n>element</span><span class=o></span> <span class=kp>in</span> <span class=n>collection</span><span class=o></span>
    <span class=c># this bit can be as complex as we like -- but not too complex!</span>
    <span class=n>do_things</span><span class=o></span><span class=p>(</span><span class=n>element</span><span class=o></span><span class=p>)</span>
<span class=k>end</span>
</code></pre></div><p>There is an important notion to mention: the <em>scope</em>. The scope is the parts of
your program in which a variable exists. Let's look at this hypothetical code:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=k>for</span> <span class=n>i</span><span class=o></span> <span class=kp>in</span> <span class=mi>1</span><span class=o>:</span><span class=mi>3</span>
    <span class=n>println</span><span class=o></span><span class=p>(</span><span class=n>i</span><span class=o></span><span class=p>)</span>
<span class=k>end</span>
</code></pre></div><p>It will take the values 1, 2, and 3, and put them in the variable <code>i</code>, one at a
time. This is like writing</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>i</span><span class=o></span> <span class=o>=</span> <span class=mi>1</span>
<span class=n>i</span><span class=o></span> <span class=o>=</span> <span class=mi>2</span>
<span class=n>i</span><span class=o></span> <span class=o>=</span> <span class=mi>3</span>
</code></pre></div><p>Right? So let's try. What do you think will happen if you run the cell below?</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=k>for</span> <span class=n>i</span><span class=o></span> <span class=kp>in</span> <span class=mi>1</span><span class=o>:</span><span class=mi>3</span>
    <span class=n>println</span><span class=o></span><span class=p>(</span><span class=n>i</span><span class=o></span><span class=p>)</span>
<span class=k>end</span>
</code></pre></div><pre><code>1
2
3
</code></pre><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia>
<span class=n>println</span><span class=o></span><span class=p>(</span><span class=n>i</span><span class=o></span><span class=p>)</span>
</code></pre></div><pre class=julia-error>
ERROR: UndefVarError: i not defined
</pre><p>What happens is that the variable <code>i</code> only exists within the <code>for</code> loop! This
might seem problematic at first, but it is actually much cleaner: this avoid
polluting your workspace with a lot of variables that are not really relevant.</p><p>This is true for all variables created within a loop. In the following code, <code>a</code>
is not defined outside of the loop:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=k>for</span> <span class=n>i</span><span class=o></span> <span class=kp>in</span> <span class=mi>1</span><span class=o>:</span><span class=mi>3</span>
    <span class=n>a</span><span class=o></span> <span class=o>=</span> <span class=n>i</span><span class=o></span>
<span class=k>end</span>
</code></pre></div><p>If you want a variable to be accessible <em>outside</em> a loop, you can simply create
it before <em>and</em> declare it as a <code>global</code> variable (this is not required within
functions, and this is the point where reading the section of the Julia manual
on scope will help you):</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>a</span><span class=o></span> <span class=o>=</span> <span class=mi>0</span>
<span class=k>for</span> <span class=n>i</span><span class=o></span> <span class=kp>in</span> <span class=mi>1</span><span class=o>:</span><span class=mi>3</span>
    <span class=kd>global</span> <span class=n>a</span><span class=o></span>
    <span class=n>a</span><span class=o></span> <span class=o>=</span> <span class=n>i</span><span class=o></span>
<span class=k>end</span>
<span class=n>println</span><span class=o></span><span class=p>(</span><span class=n>a</span><span class=o></span><span class=p>)</span>
</code></pre></div><pre><code>3
</code></pre><h2 id=doing-something-until-something-happens>Doing something until something happens</h2><p>Before moving on, there is an additional construct we can use: <code>while</code>. This one
is <em>dangerous</em> (or at the very least <em>possibly inconvenient</em>), because it will
keep on running <em>until</em> something happens. Why is not called <code>until</code>? Because
most programming languages have been designed with little regard for the way
humans think&mldr;</p><p>A good example of <code>while</code> in action is to keep on generating random numbers
<em>until</em> their mean is within a certain range of a desired value. The <code>rand()</code>
function will generate numbers uniformly distributed between 0 and 1, so we can
run it for a while (<em>GET IT?</em>) to get a sample with an average of about 0.5.</p><p>We can for example write it this way:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=k>using</span> <span class=n>Statistics</span><span class=o></span> <span class=c># We need this to use mean</span>

<span class=n>my_collection</span><span class=o></span> <span class=o>=</span> <span class=n>rand</span><span class=o></span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>

<span class=k>while</span> <span class=o>!</span><span class=p>(</span><span class=mf>0.499</span> <span class=o>â¤</span> <span class=n>mean</span><span class=o></span><span class=p>(</span><span class=n>my_collection</span><span class=o></span><span class=p>)</span> <span class=o>â¤</span> <span class=mf>0.501</span><span class=p>)</span>
  <span class=n>append!</span><span class=o></span><span class=p>(</span><span class=n>my_collection</span><span class=o></span><span class=p>,</span> <span class=n>rand</span><span class=o></span><span class=p>(</span><span class=mi>5</span><span class=p>)</span><span class=p>)</span>
<span class=k>end</span>

<span class=n>println</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>Î¼</span><span class=s>:</span><span class=s> </span><span class=si>$</span><span class=p>(</span><span class=n>round</span><span class=o></span><span class=p>(</span><span class=n>mean</span><span class=o></span><span class=p>(</span><span class=n>my_collection</span><span class=o></span><span class=p>)</span><span class=p>;</span> <span class=n>digits</span><span class=o></span><span class=o>=</span><span class=mi>4</span><span class=p>)</span><span class=p>)</span><span class=s>&#34;</span><span class=p>)</span>
</code></pre></div><pre><code>Î¼: 0.4995
</code></pre><p>The instruction just after <code>while</code>, <em>i.e.</em></p><pre><code>!(0.499 â¤ mean(my_collection) â¤ 0.501)
</code></pre><p>is worth thinking about. It is a very compact way of running multiple tests at
once: the mean needs to be larger than 0.499, yet smaller than 0.501, and we
need to continue <em>until</em> this is true (but there is not <em>until</em> statement, so we
use the awkward &ldquo;while not&rdquo;).</p><div class="callout danger">If we are particularly unlucky, we would never get a sequence of random numbers
that would match this condition! In this case, our computer would stubbornly
keep running until the heat death of the universe (or until it breaks, which in
all likelihood will happen earlier). Writing <code>while</code> loops can be a complex
exercice, and it is always good to think about &ldquo;exit strategies&rdquo;. These will be
discussed in the <a href=http://sciencecomputing.io/primers/advanced_control_flow/>&ldquo;Advanced control flow&rdquo;</a> primer.</div></section><script src=/js/ui.js></script><script>mermaid.initialize({startOnLoad:true,theme:"neutral",curve:"basis"});</script></body></html>