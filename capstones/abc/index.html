<!doctype html><html><head><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.6.1/css/all.css integrity=sha384-gfdkjb5BdAXd+lj+gudLWI+BXq4IuLW5IT+brZEZsLFm++aCMlF1V92rMkPaX4PP crossorigin=anonymous><link rel=stylesheet href=//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css><script src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.js></script><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/configuration.css><link rel=stylesheet href=/css/index.css><meta charset=utf-8><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css integrity=sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js integrity=sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js integrity=sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"$",right:"$",display:false}]});});</script><title>Approximate Bayesian Computation · Scientific computing</title></head><body><nav id=main class=sidebar><div class=toggle><a class=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><line x1="0" y1="20" x2="100" y2="20" /><line x1="0" y1="50" x2="100" y2="50" /><line x1="0" y1="80" x2="100" y2="80" /></svg></a></div><div class=header><h1><a href=/>Scientific computing</a></h1><h2>(for the rest of us)</h2></div><ul class=nav><li class=lessons><i class="fas fa-fw fa-book-open"></i><a class=sidebar-nav-item href=/lessons/>Lessons</a></li><li class=primers><i class="fas fa-fw fa-bolt"></i><a class=sidebar-nav-item href=/primers/>Primers</a></li><li class=capstones><i class="fas fa-fw fa-star"></i><a class="sidebar-nav-item active" href=/capstones/>Capstones</a></li><li class=ml><i class="fas fa-fw fa-brain"></i><a class=sidebar-nav-item href=/machinelearning/>Machine Learning</a></li><li class=main><i class="fas fa-fw fa-pen"></i><a class=sidebar-nav-item href=https://github.com/tpoisot/ScientificComputingForTheRestOfUs>Contribute!</a></li></ul></nav><section id=content><p><a href=https://en.wikipedia.org/wiki/Approximate_Bayesian_computation>Approximate Bayesian
computation</a>, or
ABC for short, is a very useful heuristic to estimate the posterior distribution
of model parameters, specifically when the analytical expression of the
likelihood function is unavailable (or when we can't be bothered to figure it
out). The theory on how ABC works will not be covered here in detail, so reading
the previous article is highly recommended.</p><p>We will rely on a few packages for this example:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=k>using</span> <span class=n>StatsPlots</span><span class=o></span>
<span class=k>using</span> <span class=n>Statistics</span><span class=o></span>
<span class=k>using</span> <span class=n>StatsBase</span><span class=o></span>
<span class=k>using</span> <span class=n>Distributions</span><span class=o></span>
</code></pre></div><p>Let us now imagine an island. It is a small island, no more than a few meters in
diameter, in the Florida keys. Every year, for 20 years, a few biologists comb
through the island, to figure out whether or not <em>Eurycotis floridana</em> is
present or absent. This results in a timeseries, like this:</p><pre><code>Year 1	absent
Year 2	absent
Year 3	absent
Year 4	absent
Year 5	absent
Year 6	absent
Year 7	present
Year 8	present
Year 9	absent
Year 10	absent
</code></pre><p>To begin with, let us see how we can model the presence/absence of this species.
We will make two assumptions. First, the biological process here can be
represented by modeling the probabilities of <em>transition</em>, <em>i.e.</em> the chance of
changing from one state to another. Second, there is a small chance of <em>error</em>
when measuring the state of the system. Specifically, while detecting at least
one individual means that there is no chance that the species is absent, <em>not</em>
detecting any individual can also mean that there were present in low density,
and have not been detected.</p><p>We can represent this system using the following figure:</p><div class=mermaid align=center>graph LR
subgraph True state
present -- e --> absent
absent -- c --> present
absent -- 1-c --> absent
present -- 1-e --> present
end
subgraph Measured state
absent --> InsectAbsent[absent]
present -- 1-m --> InsectPresent[present]
present -- m --> InsectAbsent[absent]
end</div><p>In the <em>true state</em> box, the rates represent the probabilities of state change.
The rates between <em>true state</em> and <em>measured state</em> represent the probabilities
of making the wrong measurement. We now have enough to write a simple function
to simulate this model:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=k>function</span> <span class=n>island</span><span class=o></span><span class=p>(</span><span class=nb>e</span><span class=o>:</span><span class=o>:</span><span class=n>T</span><span class=o></span><span class=p>,</span> <span class=n>c</span><span class=o></span><span class=o>:</span><span class=o>:</span><span class=n>T</span><span class=o></span><span class=p>,</span> <span class=n>m</span><span class=o></span><span class=o>:</span><span class=o>:</span><span class=n>T</span><span class=o></span><span class=p>;</span> <span class=n>n</span><span class=o></span><span class=o>=</span><span class=mi>200</span><span class=p>)</span> <span class=n>where</span><span class=o></span> <span class=p>{</span><span class=n>T</span><span class=o></span> <span class=o>&lt;</span><span class=o>:</span> <span class=kt>AbstractFloat</span><span class=p>}</span>
  <span class=nd>@assert</span><span class=o></span> <span class=mf>0.0</span> <span class=o>≤</span> <span class=nb>e</span> <span class=o>≤</span> <span class=mf>1.0</span>
  <span class=nd>@assert</span><span class=o></span> <span class=mf>0.0</span> <span class=o>≤</span> <span class=n>c</span><span class=o></span> <span class=o>≤</span> <span class=mf>1.0</span>
  <span class=nd>@assert</span><span class=o></span> <span class=mf>0.0</span> <span class=o>≤</span> <span class=n>m</span><span class=o></span> <span class=o>≤</span> <span class=mf>1.0</span>
  <span class=n>true_state</span><span class=o></span> <span class=o>=</span> <span class=n>zeros</span><span class=o></span><span class=p>(</span><span class=kt>Bool</span><span class=p>,</span> <span class=n>n</span><span class=o></span><span class=p>)</span>
  <span class=n>measured_state</span><span class=o></span> <span class=o>=</span> <span class=n>zeros</span><span class=o></span><span class=p>(</span><span class=kt>Bool</span><span class=p>,</span> <span class=n>n</span><span class=o></span><span class=p>)</span>
  <span class=n>measured_state</span><span class=o></span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>true_state</span><span class=o></span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
  <span class=k>for</span> <span class=n>year</span><span class=o></span> <span class=kp>in</span> <span class=mi>2</span><span class=o>:</span><span class=n>n</span><span class=o></span>
    <span class=n>true_state</span><span class=o></span><span class=p>[</span><span class=n>year</span><span class=o></span><span class=p>]</span> <span class=o>=</span> <span class=n>true_state</span><span class=o></span><span class=p>[</span><span class=n>year</span><span class=o></span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>?</span> <span class=n>rand</span><span class=o></span><span class=p>(</span><span class=p>)</span> <span class=o>≥</span> <span class=nb>e</span> <span class=o>:</span> <span class=n>rand</span><span class=o></span><span class=p>(</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>c</span><span class=o></span>
    <span class=n>measured_state</span><span class=o></span><span class=p>[</span><span class=n>year</span><span class=o></span><span class=p>]</span> <span class=o>=</span> <span class=n>true_state</span><span class=o></span><span class=p>[</span><span class=n>year</span><span class=o></span><span class=p>]</span> <span class=o>?</span> <span class=n>rand</span><span class=o></span><span class=p>(</span><span class=p>)</span> <span class=o>≥</span> <span class=n>m</span><span class=o></span> <span class=o>:</span> <span class=kc>false</span>
  <span class=k>end</span>
  <span class=k>return</span> <span class=n>measured_state</span><span class=o></span>
<span class=k>end</span>
</code></pre></div><pre><code>island (generic function with 1 method)
</code></pre><p>In ABC, one key notion is the idea of &ldquo;summary statistics&rdquo;, <em>i.e.</em> the act of
compressing the empirical data and model output to something that can be
meaningfully compared. Here, we will work with two informations, namely the rate
of transition, and the temporal occupancy. In ABC, the summary statistics are
<em>key</em> in determining the validity of the results. Using too much exposes you to
the curse of dimensionality, and using too few (or the wrong ones) can lead to
spurious conclusions. Another few indicators we could have used are apparent
colonisation events (when the island appeared empty one year, then occupied the
next), apparent extinction events (when the island appears occupied one year,
and empty the next), and finally the number of times where the sequence
occupied/empty/occupied appears. Feel free to try and adapt the code after you
have been through this lesson once to use these and other indicators, and see
how the results change.</p><p>In any case, here is our function to summarize a sequence of observations:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=k>function</span> <span class=n>summary</span><span class=o></span><span class=p>(</span><span class=n>t</span><span class=o></span><span class=o>:</span><span class=o>:</span><span class=kt>Vector</span><span class=p>{</span><span class=kt>Bool</span><span class=p>}</span><span class=p>)</span>
  <span class=n>transitions</span><span class=o></span> <span class=o>=</span> <span class=mf>0.0</span>
  <span class=k>for</span> <span class=n>i</span><span class=o></span> <span class=kp>in</span> <span class=mi>2</span><span class=o>:</span><span class=n>length</span><span class=o></span><span class=p>(</span><span class=n>t</span><span class=o></span><span class=p>)</span>
    <span class=k>if</span> <span class=n>t</span><span class=o></span><span class=p>[</span><span class=n>i</span><span class=o></span><span class=p>]</span> <span class=o>≠</span> <span class=n>t</span><span class=o></span><span class=p>[</span><span class=n>i</span><span class=o></span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
      <span class=n>transitions</span><span class=o></span> <span class=o>=</span> <span class=n>transitions</span><span class=o></span><span class=o>+</span><span class=mf>1.0</span>
    <span class=k>end</span>
  <span class=k>end</span>
  <span class=n>occupancy</span><span class=o></span> <span class=o>=</span> <span class=n>sum</span><span class=o></span><span class=p>(</span><span class=n>t</span><span class=o></span><span class=p>)</span><span class=o>/</span><span class=n>length</span><span class=o></span><span class=p>(</span><span class=n>t</span><span class=o></span><span class=p>)</span>
  <span class=k>return</span> <span class=p>[</span><span class=n>occupancy</span><span class=o></span><span class=p>,</span> <span class=n>transitions</span><span class=o></span><span class=o>/</span><span class=p>(</span><span class=n>length</span><span class=o></span><span class=p>(</span><span class=n>t</span><span class=o></span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span><span class=p>]</span>
<span class=k>end</span>
</code></pre></div><pre><code>summary (generic function with 1 method)
</code></pre><p>Do you like it? It's OK I guess, but I'm not a big fan. As we discussed in the
previous paragraph, we may want to use different summary statistics, and this
would require re-writing this function. This is a good example of our code being
insufficiently modular: each summary statistic should be its own function. Let's
correct this.</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>occupancy</span><span class=o></span><span class=p>(</span><span class=n>t</span><span class=o></span><span class=o>:</span><span class=o>:</span><span class=kt>Vector</span><span class=p>{</span><span class=kt>Bool</span><span class=p>}</span><span class=p>)</span> <span class=o>=</span> <span class=n>sum</span><span class=o></span><span class=p>(</span><span class=n>t</span><span class=o></span><span class=p>)</span><span class=o>/</span><span class=n>length</span><span class=o></span><span class=p>(</span><span class=n>t</span><span class=o></span><span class=p>)</span>

<span class=k>function</span> <span class=n>transitions</span><span class=o></span><span class=p>(</span><span class=n>t</span><span class=o></span><span class=o>:</span><span class=o>:</span><span class=kt>Vector</span><span class=p>{</span><span class=kt>Bool</span><span class=p>}</span><span class=p>)</span>
   <span class=n>n</span><span class=o></span> <span class=o>=</span> <span class=mf>0.0</span>
   <span class=k>for</span> <span class=n>i</span><span class=o></span> <span class=kp>in</span> <span class=mi>2</span><span class=o>:</span><span class=n>length</span><span class=o></span><span class=p>(</span><span class=n>t</span><span class=o></span><span class=p>)</span>
      <span class=k>if</span> <span class=n>t</span><span class=o></span><span class=p>[</span><span class=n>i</span><span class=o></span><span class=p>]</span> <span class=o>≠</span> <span class=n>t</span><span class=o></span><span class=p>[</span><span class=n>i</span><span class=o></span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
         <span class=n>n</span><span class=o></span> <span class=o>=</span> <span class=n>n</span><span class=o></span><span class=o>+</span><span class=mf>1.0</span>
      <span class=k>end</span>
   <span class=k>end</span>
   <span class=k>return</span> <span class=n>n</span><span class=o></span><span class=o>/</span><span class=p>(</span><span class=n>length</span><span class=o></span><span class=p>(</span><span class=n>t</span><span class=o></span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
<span class=k>end</span>
</code></pre></div><pre><code>transitions (generic function with 1 method)
</code></pre><p>We have defined two functions, each of which returns the value of one indicator.
We can now write a declaration for <code>summary</code> that will accept the states
timeseries, <em>and</em> an array of functions to measure the indicators:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=k>function</span> <span class=n>summary</span><span class=o></span><span class=p>(</span><span class=n>t</span><span class=o></span><span class=o>:</span><span class=o>:</span><span class=kt>Vector</span><span class=p>{</span><span class=kt>Bool</span><span class=p>}</span><span class=p>,</span> <span class=n>f</span><span class=o></span><span class=o>:</span><span class=o>:</span><span class=kt>Vector</span><span class=p>{</span><span class=n>T</span><span class=o></span><span class=p>}</span><span class=p>)</span> <span class=n>where</span><span class=o></span> <span class=p>{</span><span class=n>T</span><span class=o></span> <span class=o>&lt;</span><span class=o>:</span> <span class=kt>Function</span><span class=p>}</span>
   <span class=n>s</span><span class=o></span> <span class=o>=</span> <span class=n>zeros</span><span class=o></span><span class=p>(</span><span class=kt>Float64</span><span class=p>,</span> <span class=n>length</span><span class=o></span><span class=p>(</span><span class=n>f</span><span class=o></span><span class=p>)</span><span class=p>)</span>
   <span class=k>for</span> <span class=p>(</span><span class=n>i</span><span class=o></span><span class=p>,</span> <span class=n>fn</span><span class=o></span><span class=p>)</span> <span class=kp>in</span> <span class=n>enumerate</span><span class=o></span><span class=p>(</span><span class=n>f</span><span class=o></span><span class=p>)</span>
      <span class=n>s</span><span class=o></span><span class=p>[</span><span class=n>i</span><span class=o></span><span class=p>]</span> <span class=o>=</span> <span class=n>fn</span><span class=o></span><span class=p>(</span><span class=n>t</span><span class=o></span><span class=p>)</span>
   <span class=k>end</span>
   <span class=k>return</span> <span class=n>s</span><span class=o></span>
<span class=k>end</span>
</code></pre></div><pre><code>summary (generic function with 2 methods)
</code></pre><p>Is it perfect? No. Is it an improvement over the previous implementation?
Assuredly, so let's roll with this. We can apply this function to a simulation
with parameters $(e=0.2, c=0.6, m=0.1)$, and get the summary statistics:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>summary</span><span class=o></span><span class=p>(</span>
   <span class=n>island</span><span class=o></span><span class=p>(</span><span class=mf>0.2</span><span class=p>,</span> <span class=mf>0.6</span><span class=p>,</span> <span class=mf>0.1</span><span class=p>)</span><span class=p>,</span>   <span class=c># simulation output</span>
   <span class=p>[</span><span class=n>occupancy</span><span class=o></span><span class=p>,</span> <span class=n>transitions</span><span class=o></span><span class=p>]</span> <span class=c># list of things to measure</span>
   <span class=p>)</span>
</code></pre></div><pre><code>2-element Array{Float64,1}:
 0.69               
 0.40703517587939697
</code></pre><p>At this point, we need empirical data to feed the model. Let's say that over
twenty years, the species has been observed from year 4 to 12, then 14 to 15,
and finally from year 17 to 20. We can write this as:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>empirical_data</span><span class=o></span> <span class=o>=</span> <span class=n>zeros</span><span class=o></span><span class=p>(</span><span class=kt>Bool</span><span class=p>,</span> <span class=mi>20</span><span class=p>)</span>
<span class=n>empirical_data</span><span class=o></span><span class=p>[</span><span class=mi>4</span><span class=o>:</span><span class=mi>12</span><span class=p>]</span> <span class=o>.=</span> <span class=kc>true</span>
<span class=n>empirical_data</span><span class=o></span><span class=p>[</span><span class=mi>14</span><span class=o>:</span><span class=mi>15</span><span class=p>]</span> <span class=o>.=</span> <span class=kc>true</span>
<span class=n>empirical_data</span><span class=o></span><span class=p>[</span><span class=mi>17</span><span class=o>:</span><span class=mi>20</span><span class=p>]</span> <span class=o>.=</span> <span class=kc>true</span>
</code></pre></div><p>Your biologist colleague would be very happy if you could get to an estimate of
the parameters that govern the presence of this insect on the island. This is an
easy enough task to do with ABC.</p><p>We can measure the statistics of this timeseries:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>summary</span><span class=o></span><span class=p>(</span><span class=n>empirical_data</span><span class=o></span><span class=p>)</span>
</code></pre></div><pre><code>2-element Array{Float64,1}:
 0.75              
 0.2631578947368421
</code></pre><p>And just like this, we are ready to start the ABC process. We will start by
deciding on priors for all three parameters. We could model them in a variety of
ways, including β laws, and truncated distributions. Let's go with the later, as
it is a neat illustration of the <code>Distributions</code> package. We picked a value of
colonisation higher than extinction (as the species seems to persist), and a
relatively low rate of false absences.</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>Dc</span><span class=o></span> <span class=o>=</span> <span class=n>Truncated</span><span class=o></span><span class=p>(</span><span class=n>Normal</span><span class=o></span><span class=p>(</span><span class=mf>0.6</span><span class=p>,</span> <span class=mf>0.1</span><span class=p>)</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>)</span>
<span class=n>De</span><span class=o></span> <span class=o>=</span> <span class=n>Truncated</span><span class=o></span><span class=p>(</span><span class=n>Normal</span><span class=o></span><span class=p>(</span><span class=mf>0.3</span><span class=p>,</span> <span class=mf>0.1</span><span class=p>)</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>)</span>
<span class=n>Dm</span><span class=o></span> <span class=o>=</span> <span class=n>Truncated</span><span class=o></span><span class=p>(</span><span class=n>Normal</span><span class=o></span><span class=p>(</span><span class=mf>0.1</span><span class=p>,</span> <span class=mf>0.3</span><span class=p>)</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>)</span>
</code></pre></div><p>In this algorithm (as with any other Bayesian application), priors are
<em>determinant</em> in the success of the process; indeed, the posterior distribution
will be a subset of the prior, because (as we discuss below) ABC relies on
<em>rejection</em> sampling, <em>i.e.</em> it winnows parameter values that make little sense
from the original distribution. Picking a prior which is too narrow will prevent
the algorithm from converging onto the correct posterior. Conversely, picking a
prior that is too flat (let's say a uniform distribution that goes from negative
infinity to positive infinity) means that the time to convergence will explode.</p><p>We will generate 10⁶ samples using our simulation model, and get the summary
statistics for all of them. Note that the simulations run for 200 timesteps, as
opposed to 20 for the empirical data. This is perfectly fine, because ABC works
on summary statistics. An interesting exercise is to change the number of
timesteps in the simulations, and see if/how the posterior distributions react.</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>N</span><span class=o></span> <span class=o>=</span> <span class=mi>1_000_000</span>
<span class=n>Sc</span><span class=o></span> <span class=o>=</span> <span class=n>rand</span><span class=o></span><span class=p>(</span><span class=n>Dc</span><span class=o></span><span class=p>,</span> <span class=n>N</span><span class=o></span><span class=p>)</span>
<span class=n>Se</span><span class=o></span> <span class=o>=</span> <span class=n>rand</span><span class=o></span><span class=p>(</span><span class=n>De</span><span class=o></span><span class=p>,</span> <span class=n>N</span><span class=o></span><span class=p>)</span>
<span class=n>Sm</span><span class=o></span> <span class=o>=</span> <span class=n>rand</span><span class=o></span><span class=p>(</span><span class=n>Dm</span><span class=o></span><span class=p>,</span> <span class=n>N</span><span class=o></span><span class=p>)</span>
<span class=n>simulated_results</span><span class=o></span> <span class=o>=</span> <span class=n>summary</span><span class=o></span><span class=o>.</span><span class=p>(</span><span class=n>map</span><span class=o></span><span class=p>(</span><span class=n>i</span><span class=o></span> <span class=o>-</span><span class=o>&gt;</span> <span class=n>island</span><span class=o></span><span class=p>(</span><span class=n>Se</span><span class=o></span><span class=p>[</span><span class=n>i</span><span class=o></span><span class=p>]</span><span class=p>,</span> <span class=n>Sc</span><span class=o></span><span class=p>[</span><span class=n>i</span><span class=o></span><span class=p>]</span><span class=p>,</span> <span class=n>Sm</span><span class=o></span><span class=p>[</span><span class=n>i</span><span class=o></span><span class=p>]</span><span class=p>)</span><span class=p>,</span> <span class=mi>1</span><span class=o>:</span><span class=n>N</span><span class=o></span><span class=p>)</span><span class=p>)</span>
</code></pre></div><div class="callout opinion">ABC is an excellent exercise for parallel computing! Because the model runs are
independant, this is an &ldquo;embarrassingly parallel&rdquo; problem. After reading the
<a href=/primers/parallelcomputing/>parallel computing</a> primer, you may want to try it
out on this problem.</div><p>We can now measure the distance between these simulated results and the
empirical results:</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=k>function</span> <span class=n>euclidean_distance</span><span class=o></span><span class=p>(</span><span class=n>x1</span><span class=o></span><span class=o>:</span><span class=o>:</span><span class=kt>Vector</span><span class=p>{</span><span class=n>T</span><span class=o></span><span class=p>}</span><span class=p>,</span> <span class=n>x2</span><span class=o></span><span class=o>:</span><span class=o>:</span><span class=kt>Vector</span><span class=p>{</span><span class=n>T</span><span class=o></span><span class=p>}</span><span class=p>)</span> <span class=n>where</span><span class=o></span> <span class=p>{</span><span class=n>T</span><span class=o></span> <span class=o>&lt;</span><span class=o>:</span> <span class=kt>AbstractFloat</span><span class=p>}</span>
  <span class=k>return</span> <span class=n>sum</span><span class=o></span><span class=p>(</span><span class=n>sqrt</span><span class=o></span><span class=o>.</span><span class=p>(</span><span class=p>(</span><span class=n>x1</span><span class=o></span><span class=o>.-</span><span class=n>x2</span><span class=o></span><span class=p>)</span><span class=o>.^</span><span class=mf>2.0</span><span class=p>)</span><span class=p>)</span>
<span class=k>end</span>
<span class=n>distances</span><span class=o></span> <span class=o>=</span> <span class=n>map</span><span class=o></span><span class=p>(</span><span class=n>s</span><span class=o></span> <span class=o>-</span><span class=o>&gt;</span> <span class=n>euclidean_distance</span><span class=o></span><span class=p>(</span><span class=n>s</span><span class=o></span><span class=p>,</span> <span class=n>summary</span><span class=o></span><span class=p>(</span><span class=n>empirical_data</span><span class=o></span><span class=p>)</span><span class=p>)</span><span class=p>,</span> <span class=n>simulated_results</span><span class=o></span><span class=p>)</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>density</span><span class=o></span><span class=p>(</span><span class=n>distances</span><span class=o></span><span class=p>,</span> <span class=n>leg</span><span class=o></span><span class=o>=</span><span class=kc>false</span><span class=p>,</span> <span class=n>fill</span><span class=o></span><span class=o>=</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>:</span><span class=n>orange</span><span class=o></span><span class=p>,</span> <span class=mf>0.4</span><span class=p>)</span><span class=p>,</span> <span class=n>c</span><span class=o></span><span class=o>=</span><span class=o>:</span><span class=n>orange</span><span class=o></span><span class=p>)</span>
<span class=n>xaxis!</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>D</span><span class=s>i</span><span class=s>s</span><span class=s>t</span><span class=s>a</span><span class=s>n</span><span class=s>c</span><span class=s>e</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>)</span><span class=p>)</span>
<span class=n>yaxis!</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>D</span><span class=s>e</span><span class=s>n</span><span class=s>s</span><span class=s>i</span><span class=s>t</span><span class=s>y</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span><span class=p>)</span>
</code></pre></div><figure><img src=../figures/abc_13_1.png><figcaption><h4>Distance between the summaries of empirical and actual data.</h4></figcaption></figure><p>The actual ABC step is to <em>reject</em> some of the samples from them prior
distribution, to only select the parameters combinations that produce results
<em>close</em> to the empirical data. This is done by setting a threshold, and
distances <em>above</em> this threshold will be rejected (this is why the choice of a
good prior distribution is crucial). In this case, we picked a threshold value
of $\theta = 0.02$. Why? Well, for the same reason we idolize $p \le 0.05$:
&ldquo;dunno, it looks fine I guess?". You are, once again, encouraged to change this
value, and the density of distances presented in the previous plot should help
you decide which values are too large or too small; and as always, you can
increase the number of samples if you want to be very strict.</p><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>θ</span><span class=o></span> <span class=o>=</span> <span class=mf>0.02</span>
<span class=n>posterior</span><span class=o></span> <span class=o>=</span> <span class=n>findall</span><span class=o></span><span class=p>(</span><span class=n>distances</span><span class=o></span><span class=o>.&lt;</span><span class=n>θ</span><span class=o></span><span class=p>)</span>
</code></pre></div><div class="callout information">Another approach to rejection sampling would be to keep generating samples until
the sample size of the posterior has reached a certain threshold. Both solutions
are valid, but for the sake of illustration, we went with the one that was
simpler to implement. Feel free to work on other rejection samplers as a
programming exercise.</div><div class=highlight><pre class=chroma><code class=language-julia data-lang=julia><span class=n>density</span><span class=o></span><span class=p>(</span><span class=n>Sc</span><span class=o></span><span class=p>,</span> <span class=n>c</span><span class=o></span><span class=o>=</span><span class=o>:</span><span class=n>teal</span><span class=o></span><span class=p>,</span> <span class=n>ls</span><span class=o></span><span class=o>=</span><span class=o>:</span><span class=n>dash</span><span class=o></span><span class=p>,</span> <span class=n>lab</span><span class=o></span><span class=o>=</span><span class=s>&#34;</span><span class=s>&#34;</span><span class=p>)</span>
<span class=n>density!</span><span class=o></span><span class=p>(</span><span class=n>Se</span><span class=o></span><span class=p>,</span> <span class=n>c</span><span class=o></span><span class=o>=</span><span class=o>:</span><span class=n>purple</span><span class=o></span><span class=p>,</span> <span class=n>ls</span><span class=o></span><span class=o>=</span><span class=o>:</span><span class=n>dash</span><span class=o></span><span class=p>,</span> <span class=n>lab</span><span class=o></span><span class=o>=</span><span class=s>&#34;</span><span class=s>&#34;</span><span class=p>)</span>
<span class=n>density!</span><span class=o></span><span class=p>(</span><span class=n>Sm</span><span class=o></span><span class=p>,</span> <span class=n>c</span><span class=o></span><span class=o>=</span><span class=o>:</span><span class=n>grey</span><span class=o></span><span class=p>,</span> <span class=n>ls</span><span class=o></span><span class=o>=</span><span class=o>:</span><span class=n>dash</span><span class=o></span><span class=p>,</span> <span class=n>lab</span><span class=o></span><span class=o>=</span><span class=s>&#34;</span><span class=s>&#34;</span><span class=p>)</span>

<span class=n>density!</span><span class=o></span><span class=p>(</span><span class=n>Sc</span><span class=o></span><span class=p>[</span><span class=n>posterior</span><span class=o></span><span class=p>]</span><span class=p>,</span> <span class=n>c</span><span class=o></span><span class=o>=</span><span class=o>:</span><span class=n>teal</span><span class=o></span><span class=p>,</span> <span class=n>fill</span><span class=o></span><span class=o>=</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>:</span><span class=n>teal</span><span class=o></span><span class=p>,</span> <span class=mf>0.3</span><span class=p>)</span><span class=p>,</span> <span class=n>lab</span><span class=o></span><span class=o>=</span><span class=s>&#34;</span><span class=s>C</span><span class=s>o</span><span class=s>l</span><span class=s>o</span><span class=s>n</span><span class=s>i</span><span class=s>z</span><span class=s>a</span><span class=s>t</span><span class=s>i</span><span class=s>o</span><span class=s>n</span><span class=s>&#34;</span><span class=p>)</span>
<span class=n>density!</span><span class=o></span><span class=p>(</span><span class=n>Se</span><span class=o></span><span class=p>[</span><span class=n>posterior</span><span class=o></span><span class=p>]</span><span class=p>,</span> <span class=n>c</span><span class=o></span><span class=o>=</span><span class=o>:</span><span class=n>purple</span><span class=o></span><span class=p>,</span> <span class=n>fill</span><span class=o></span><span class=o>=</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>:</span><span class=n>purple</span><span class=o></span><span class=p>,</span> <span class=mf>0.3</span><span class=p>)</span><span class=p>,</span> <span class=n>lab</span><span class=o></span><span class=o>=</span><span class=s>&#34;</span><span class=s>E</span><span class=s>x</span><span class=s>t</span><span class=s>i</span><span class=s>n</span><span class=s>c</span><span class=s>t</span><span class=s>i</span><span class=s>o</span><span class=s>n</span><span class=s>&#34;</span><span class=p>)</span>
<span class=n>density!</span><span class=o></span><span class=p>(</span><span class=n>Sm</span><span class=o></span><span class=p>[</span><span class=n>posterior</span><span class=o></span><span class=p>]</span><span class=p>,</span> <span class=n>c</span><span class=o></span><span class=o>=</span><span class=o>:</span><span class=n>grey</span><span class=o></span><span class=p>,</span> <span class=n>fill</span><span class=o></span><span class=o>=</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>:</span><span class=n>grey</span><span class=o></span><span class=p>,</span> <span class=mf>0.3</span><span class=p>)</span><span class=p>,</span> <span class=n>lab</span><span class=o></span><span class=o>=</span><span class=s>&#34;</span><span class=s>E</span><span class=s>r</span><span class=s>r</span><span class=s>o</span><span class=s>r</span><span class=s>&#34;</span><span class=p>)</span>

<span class=n>xaxis!</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>P</span><span class=s>a</span><span class=s>r</span><span class=s>a</span><span class=s>m</span><span class=s>e</span><span class=s>t</span><span class=s>e</span><span class=s>r</span><span class=s> </span><span class=s>v</span><span class=s>a</span><span class=s>l</span><span class=s>u</span><span class=s>e</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>)</span><span class=p>)</span>
<span class=n>yaxis!</span><span class=o></span><span class=p>(</span><span class=s>&#34;</span><span class=s>D</span><span class=s>e</span><span class=s>n</span><span class=s>s</span><span class=s>i</span><span class=s>t</span><span class=s>y</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>14</span><span class=p>)</span><span class=p>)</span>
</code></pre></div><figure><img src=../figures/abc_15_1.png><figcaption><h4>Posterior distributions (shaded) and the corresponding priors (dashed) for the three parameters in the model.</h4></figcaption></figure><p>To summarize, we can now extract the values of the different parameters:</p><table><thead><tr><th align=center></th><th align=left>meaning</th><th align=right>mean</th><th align=right>standard deviation</th></tr></thead><tbody><tr><td align=center>$c$</td><td align=left>Colonization rate</td><td align=right>0.551</td><td align=right>0.067</td></tr><tr><td align=center>$e$</td><td align=left>Extinction rate</td><td align=right>0.153</td><td align=right>0.041</td></tr><tr><td align=center>$m$</td><td align=left>Measurement error rate</td><td align=right>0.052</td><td align=right>0.041</td></tr></tbody></table><p>Done! One of the strength of ABC is that we can now <em>generate</em> datasets, using
our original model for simulation. And because we know the measurement error
rate, we can also correct these datasets to describe the data <em>generation</em>
process (the actual presence/absence of the species) as opposed to the data
<em>observation</em> process (measuring the presence/absence and being sometimes wrong
about it).</p></section><script src=/js/ui.js></script><script>mermaid.initialize({startOnLoad:true,theme:"neutral",curve:"basis"});</script></body></html>