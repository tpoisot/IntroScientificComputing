<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>control flow on</title><link>http://sciencecomputing.io/concepts/control-flow/</link><description>Recent content in control flow on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://sciencecomputing.io/concepts/control-flow/index.xml" rel="self" type="application/rss+xml"/><item><title>Advanced control flow</title><link>http://sciencecomputing.io/primers/advanced_control_flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://sciencecomputing.io/primers/advanced_control_flow/</guid><description>In the first lesson, we have presented the flow of execution as something largely unescapable. In practice, there are two important operations we may want to perform: skip an iteration, or stop the iteration process entirely. In this primer, we will see how this can be achieved using the break and next keywords.
Understanding how next and break can be used is extremely useful as you start developing more complex workflows.</description></item><item><title>Approximate Bayesian Computation</title><link>http://sciencecomputing.io/capstones/abc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://sciencecomputing.io/capstones/abc/</guid><description>Approximate Bayesian computation, or ABC for short, is a very useful heuristic to estimate the posterior distribution of model parameters, specifically when the analytical expression of the likelihood function is unavailable (or when we can't be bothered to figure it out). The theory on how ABC works will not be covered here in detail, so reading the previous article is highly recommended.
We will rely on a few packages for this example:</description></item><item><title>Before we start...</title><link>http://sciencecomputing.io/lessons/planning_ahead/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://sciencecomputing.io/lessons/planning_ahead/</guid><description>Programming is intimidating If your working environment looks anything like mine, the first thing you may see on a new project will look like this - an empty text editor, and an empty code interpreter. This is highly intimidating.
Facing an empty text editor at the beginning of a programming task is like facing an empty page at the beginning of a writing project. To make it easier to work through, one really good (but also really uncommon) approach is to walk away from the computer.</description></item><item><title>Neural network with Flux</title><link>http://sciencecomputing.io/machinelearning/neuralnetwork/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://sciencecomputing.io/machinelearning/neuralnetwork/</guid><description>short intro text goes here
using Flux ERROR: On worker 2: ArgumentError: Package Flux &amp;#91;587475ba-b771-5e3f-ad9e-33799f191a9c&amp;#93; is required but does not seem to be installed: - Run &amp;#96;Pkg.instantiate&amp;#40;&amp;#41;&amp;#96; to install all recorded dependencies. _require at ./loading.jl:982 require at ./loading.jl:911 #2 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.2/Distributed/src/Distributed.jl:78 #116 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.2/Distributed/src/process_messages.jl:307 run_work_thunk at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.2/Distributed/src/process_messages.jl:79 run_work_thunk at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.2/Distributed/src/process_messages.jl:88 #102 at ./task.jl:268 #remotecall_wait#154&amp;#40;::Base.Iterators.Pairs&amp;#123;Union&amp;#123;&amp;#125;,Union&amp;#123;&amp;#125;,Tuple&amp;#123;&amp;#125;,NamedTuple&amp;#123;&amp;#40;&amp;#41;,Tuple&amp;#123;&amp;#125;&amp;#125;&amp;#125;, ::typeof&amp;#40;Distributed.remotecall_wait&amp;#41;, ::Function, ::Distributed.Worker&amp;#41; at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.2/Distributed/src/remotecall.jl:421 remotecall_wait&amp;#40;::Function, ::Distributed.Worker&amp;#41; at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.2/Distributed/src/remotecall.jl:412 #remotecall_wait#157&amp;#40;::Base.Iterators.Pairs&amp;#123;Union&amp;#123;&amp;#125;,Union&amp;#123;&amp;#125;,Tuple&amp;#123;&amp;#125;,NamedTuple&amp;#123;&amp;#40;&amp;#41;,Tuple&amp;#123;&amp;#125;&amp;#125;&amp;#125;, ::typeof&amp;#40;Distributed.remotecall_wait&amp;#41;, ::Function, ::Int64&amp;#41; at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.2/Distributed/src/remotecall.jl:433 remotecall_wait at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.</description></item><item><title>Neural Bayes classifier</title><link>http://sciencecomputing.io/machinelearning/naivebayes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://sciencecomputing.io/machinelearning/naivebayes/</guid><description>In this capstone, we will implement a Naive Bayes classifier, to make predictions about the cultivar to which wheat seeds belong. This is a classification task, meaning that we want to get an answer that looks like class A or class B, as opposed to a regression problem in which we would like to get an answer like length = 0.8cm. At its core, Naive Bayes classification assumes that the probability of belonging to a class based on a single measurement is equal to the probability that this measurement's values originate from the distribution of known values for the class.</description></item><item><title>The flow of execution</title><link>http://sciencecomputing.io/lessons/control_flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://sciencecomputing.io/lessons/control_flow/</guid><description>Programming really is a language But if you understand three words, you will be able to hold a good conversation with your computer! These three words are if, for, and while. If you have some previous experience with writing code, you can skim through this lesson.
One great way to make your code robust is to keep it very simple, and one great way to keep your code very simple is to recognize that often, we want to do one of three things: do one thing if something happens (if), do one thing to a series of things (for), or do one thing until something happens (while).</description></item></channel></rss>